<!DOCTYPE html><html lang="null"><head><meta name="generator" content="Hexo 3.8.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>JavaScript进阶 | Sesame Record</title><link rel="stylesheet" type="text/css" href="//fonts.neworld.org/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript进阶</h1><a id="logo" href="/.">Sesame Record</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Start</i></a><a href="/archives/"><i class="fa fa-archive"> Archiv</i></a><a href="/about/"><i class="fa fa-user"> Über</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript进阶</h1><div class="post-meta"><a href="/2018/12/27/javascript进阶/#comments" class="comment-count"></a><p><span class="date">Dec 27, 2018</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>Schlägt</i></i></span></p></div><div class="post-content"><h1 id="一、ES6基础"><a href="#一、ES6基础" class="headerlink" title="一、ES6基础"></a>一、ES6基础</h1><h2 id="1-ECMAScript-6-简介"><a href="#1-ECMAScript-6-简介" class="headerlink" title="1. ECMAScript 6 简介"></a>1. ECMAScript 6 简介</h2><p>ECMAScript(ES6) 是JavaScript语言的下一代标准，已经在2015年6月正式发布了；在 JavaScript 的基础上做了重大的更新，提供了更优雅的语法和特性。</p>
<h4 id="ECMAScript-和-JavaScript-的关系"><a href="#ECMAScript-和-JavaScript-的关系" class="headerlink" title="ECMAScript 和 JavaScript 的关系"></a>ECMAScript 和 JavaScript 的关系</h4><p>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。日常场合，这两个词是可以互换的。那为什么不叫 JavaScript 为换名字了呢？原因如下：</p>
<ol>
<li>商标，1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。根据授权协议，只有Netscape公司(Javascript 的创造者)可以合法地使用JavaScript这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。</li>
<li>想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</li>
</ol>
<h2 id="2-ES6-新特性"><a href="#2-ES6-新特性" class="headerlink" title="2. ES6 新特性"></a>2. ES6 新特性</h2><h3 id="let-和-const"><a href="#let-和-const" class="headerlink" title="let 和 const"></a>let 和 const</h3><p>ES6提供了两种新的声明变量的方式：let 和 const。其中let 和 const 相比于 var 声明的变量有块作用域，let 和 const 只在于当前的块作用域中有效。而 var 声明的变量是在函数作用域内有效。<br>没有块级作用域，会出现很多不合理的情况。<br>1、内层变量可能会覆盖外层变量。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var n = 5;		</span><br><span class="line">function f1() &#123;</span><br><span class="line">  console.log(n); </span><br><span class="line">  if (true) &#123;</span><br><span class="line">    var n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();  //undefined</span><br></pre></td></tr></table></figure></p>
<p>发生了变量提升，导致内层的n变量覆盖了外层的n变量。 而块级作用域不存在变量提升 ，let所声明的变量一定要在声明后使用，否则就会报错。上述代码如果使用let进行声明，则会报错。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let n = 5;		</span><br><span class="line">function f1() &#123;</span><br><span class="line">  console.log(n); </span><br><span class="line">  if (true) &#123;</span><br><span class="line">    let n = 10;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f1();  //报错</span><br></pre></td></tr></table></figure></p>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”。这样可以减少运行时的错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。<br>2、用来计数的循环变量会泄露为全局变量。例如下面的代码如果使用var，最后输出的是10。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 10</span><br></pre></td></tr></table></figure></p>
<p>其中变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。<br>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a = [];</span><br><span class="line">for (let i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  a[i] = function () &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[6](); // 6</span><br></pre></td></tr></table></figure></p>
<p>变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<h3 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h3><p>按照一定的模式，从数组或对象中提取值，对变量进行赋值的操作。</p>
<h4 id="数组的解构"><a href="#数组的解构" class="headerlink" title="数组的解构"></a>数组的解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var [a,b,c] = [1,2,3] // 结果 a=1 b=2 c=3</span><br><span class="line">var [a,[b,c]] = [1,[2,3]] // 结果 a=1 b=2 c=3</span><br><span class="line"></span><br><span class="line">//解构不成功</span><br><span class="line">var [a] = [];  // a = undefined   </span><br><span class="line">var [a, b] = [1]; //a=1 b=undefined</span><br><span class="line"></span><br><span class="line">//不完全解构</span><br><span class="line">var [a] = [1,2]; //a=1</span><br><span class="line"></span><br><span class="line">//默认值</span><br><span class="line">var [a=1] = [] //a=1</span><br></pre></td></tr></table></figure>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let [a] = 1;</span><br><span class="line">let [a] = false;</span><br><span class="line">let [a] = NaN;</span><br><span class="line">let [a] = undefined;</span><br><span class="line">let [a] = null;</span><br><span class="line">let [a] = &#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="对象的解构"><a href="#对象的解构" class="headerlink" title="对象的解构"></a>对象的解构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var &#123; b, a &#125; = &#123; a: &quot;aaa&quot;, b: &quot;bbb&quot; &#125;;</span><br><span class="line">a // &quot;aaa&quot;</span><br><span class="line">b // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拓展"><a href="#字符串拓展" class="headerlink" title="字符串拓展"></a>字符串拓展</h3><h4 id="模版字符串"><a href="#模版字符串" class="headerlink" title="模版字符串"></a>模版字符串</h4><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串（类似 pre 标签的作用），或者在字符串中嵌入变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串 想要换行需要加上 &apos;\n&apos;</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">var name = &quot;ac&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` // Hello ac, how are you today?</span><br></pre></td></tr></table></figure></p>
<h4 id="rest-展开运算符"><a href="#rest-展开运算符" class="headerlink" title="rest 展开运算符"></a>rest 展开运算符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function example(...values)&#123;</span><br><span class="line">    console.log(values)// console: [1,2,3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1,2,3,4) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a = [1,2,3]</span><br><span class="line"></span><br><span class="line">var b = [...a,4,5,6] //b = [1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6 提供了新的方式 =&gt; 来定义函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var func = parm =&gt; parm</span><br><span class="line">等同于</span><br><span class="line">var func = function (parm)&#123;</span><br><span class="line">    return parm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数没有参数或有多个参数，那么：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var func = () =&gt; //some code</span><br><span class="line">等同于</span><br><span class="line">var func = function ()&#123;</span><br><span class="line">	some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func = (parm1,parm2) =&gt; //some code</span><br><span class="line">等同于</span><br><span class="line">var func = function (parm1,parm2)&#123;</span><br><span class="line">	some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果箭头函数的函数体只包含一行代码，则可以不需要写大括号以及 return 语句返回（如果有返回值）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1,num2) =&gt; num1+num2</span><br><span class="line">等同于</span><br><span class="line">var sum = (num1,num2) =&gt; &#123;return num1+num2&#125;</span><br><span class="line">等同于</span><br><span class="line">var sum = function(num1,num2)&#123;return num1+num2&#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数使得表达更加简洁<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3].map( item=&gt; 2 * item)</span><br><span class="line">等同于</span><br><span class="line">[1,2,3].map(function(item)&#123;</span><br><span class="line">    return item * 2</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">[1,3,2].sort((a,b) =&gt; a - b)</span><br></pre></td></tr></table></figure></p>
<h1 id="二、面向对象基础"><a href="#二、面向对象基础" class="headerlink" title="二、面向对象基础"></a>二、面向对象基础</h1><h2 id="什么是面向对象编程"><a href="#什么是面向对象编程" class="headerlink" title="什么是面向对象编程"></a>什么是面向对象编程</h2><ul>
<li>把一组数据结构和处理它们的方法组成对象(Object)；</li>
<li>把相同行为的对象归纳为类(Class), 通过类的封装(encapsulation)隐藏内部细节；</li>
<li>通过继承(inheritance)实现类的特化(specializetion)/泛化(generalization),；</li>
<li>通过多态(polymorphism)实现基于对象类型的动态分派。</li>
</ul>
<h2 id="面向对象的好处？"><a href="#面向对象的好处？" class="headerlink" title="面向对象的好处？"></a>面向对象的好处？</h2><ol>
<li>接近人的思维，符合人类对现实世界的认知；</li>
<li>封装特性可以使开发者不必在意内部的具体实现，更方便互相协作；</li>
<li>继承特性可以减少代码冗余，实现代码复用；</li>
<li>多态特性令子类相比父类有不同的行为，这是非常接近现实的；</li>
</ol>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="1、字面量模式"><a href="#1、字面量模式" class="headerlink" title="1、字面量模式"></a>1、字面量模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var Cat = &#123;</span><br><span class="line">　name : &apos;&apos;,</span><br><span class="line">　color : &apos;&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的方法的缺点是如果多生成几个实例，写起来就非常麻烦。</p>
<h3 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color) &#123;</span><br><span class="line">　return &#123;</span><br><span class="line">　   name:name,</span><br><span class="line">　   color:color　　</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写可以解决生成多个实例的问题，比较方便，但是调用之后实例的类型只是一个普通的对象，而不是一个具体的类型。</p>
<h3 id="3、构造函数模式"><a href="#3、构造函数模式" class="headerlink" title="3、构造函数模式"></a>3、构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color)&#123;</span><br><span class="line">   this.name=name;</span><br><span class="line">   this.color=color;</span><br><span class="line">   this.eat = function()&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">var cat1 = new Cat(&quot;big&quot;,&quot;yellow&quot;);</span><br><span class="line">var cat2 = new Cat(&quot;small&quot;,&quot;black&quot;);</span><br></pre></td></tr></table></figure>
<p>这样解决了实例不为一个特定类型的问题，使用instanceof运算符可以验证原型对象与实例对象之间的关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(cat1 instanceof Cat); //true</span><br></pre></td></tr></table></figure></p>
<p>但是这样有一个问题是：每一次生成一个实例，都会产生一个新的内容一模一样的方法，是重复的部分，会多占用内存空间。</p>
<h3 id="4、原型模式"><a href="#4、原型模式" class="headerlink" title="4、原型模式"></a>4、原型模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Cat()&#123; &#125;</span><br><span class="line">Cat.prototype = &#123;  </span><br><span class="line">   type=&apos;animal&apos;;</span><br><span class="line">   this.eat = function()&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用原型模式所有实例的type属性和eat()方法，其实都是同一个内存地址，指向prototype对象，因此就提高了运行效率。但是对任何一个实例的操作会影响到所有的实例。</p>
<h3 id="5、混合模式"><a href="#5、混合模式" class="headerlink" title="5、混合模式"></a>5、混合模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.color = color;</span><br><span class="line">&#125;</span><br><span class="line">Cat.prototype.type = &quot;animal&quot;;</span><br><span class="line">Cat.prototype.eat = function()&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>需要变化的属性使用构造函数定义，不变的属性和方法使用原型来定义。但是这种写法不够美观。</p>
<h3 id="6、类"><a href="#6、类" class="headerlink" title="6、类"></a>6、类</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。新的class写法可以让对象原型的写法更加清晰、更像面向对象编程的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Cat()&#123;</span><br><span class="line">  constructor(name,color) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  eat() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>Class 可以通过extends关键字实现继承，例如定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>super关键字表示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用super方法，子类就得不到this对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><div class="tags"></div><div class="post-share"><div class="bdsharebuttonbox"><span style="float:left;line-height: 28px;height: 28px;font-size:16px;font-weight:blod">分享到：</span><a href="#" data-cmd="more" class="bds_more"></a><a href="#" data-cmd="mshare" title="分享到一键分享" class="bds_mshare"></a><a href="#" data-cmd="fbook" title="分享到Facebook" class="bds_fbook"></a><a href="#" data-cmd="twi" title="分享到Twitter" class="bds_twi"></a><a href="#" data-cmd="linkedin" title="分享到linkedin" class="bds_linkedin"></a><a href="#" data-cmd="youdao" title="分享到有道云笔记" class="bds_youdao"></a><a href="#" data-cmd="evernotecn" title="分享到印象笔记" class="bds_evernotecn"></a><a href="#" data-cmd="weixin" title="分享到微信" class="bds_weixin"></a><a href="#" data-cmd="qzone" title="分享到QQ空间" class="bds_qzone"></a><a href="#" data-cmd="tsina" title="分享到新浪微博" class="bds_tsina"></a></div></div><div class="post-nav"><a href="/2018/12/13/js基础1/" class="next">JavaScript基础（一）</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">Inhalte</i></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、ES6基础"><span class="toc-text">一、ES6基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ECMAScript-6-简介"><span class="toc-text">1. ECMAScript 6 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ECMAScript-和-JavaScript-的关系"><span class="toc-text">ECMAScript 和 JavaScript 的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-ES6-新特性"><span class="toc-text">2. ES6 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#let-和-const"><span class="toc-text">let 和 const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量的解构赋值"><span class="toc-text">变量的解构赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的解构"><span class="toc-text">数组的解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的解构"><span class="toc-text">对象的解构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串拓展"><span class="toc-text">字符串拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#模版字符串"><span class="toc-text">模版字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rest-展开运算符"><span class="toc-text">rest 展开运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#箭头函数"><span class="toc-text">箭头函数</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#二、面向对象基础"><span class="toc-text">二、面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是面向对象编程"><span class="toc-text">什么是面向对象编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#面向对象的好处？"><span class="toc-text">面向对象的好处？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#封装"><span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、字面量模式"><span class="toc-text">1、字面量模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、工厂模式"><span class="toc-text">2、工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、构造函数模式"><span class="toc-text">3、构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、原型模式"><span class="toc-text">4、原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、混合模式"><span class="toc-text">5、混合模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6、类"><span class="toc-text">6、类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-text">继承</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> Letzte</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/javascript进阶/">JavaScript进阶</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/13/js基础1/">JavaScript基础（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/13/js基础2/">JavaScript基础（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/25/CSS/">css summary</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/html-summary/">html summary</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/ask/">The method of asking</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/11/19/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> Tags</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> Archiv</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-you"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">Baidu Site Haritası</a> |  <a href="/atom.xml">RSS</a> |  <a href="/about/">Über</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次</p><p><span> Copyright &copy;<a href="/." rel="nofollow">Wei Linxiao.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script><script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","weixin","tsina","qzone","linkedin","fbook","twi","print","renren","sqq","evernotecn","bdysc","tqq","tqf","bdxc","kaixin001","tieba","douban","bdhome","thx","ibaidu","meilishuo","mogujie","diandian","huaban","duitang","hx","fx","youdao","sdo","qingbiji","people","xinhua","mail","isohu","yaolan","wealink","ty","iguba","h163","copy"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["tsina","qzone","weixin","fbook","twi","linkedin","youdao","evernotecn","mshare"]}};with(document)0[(getElementsByTagName('head')[0]||head).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
</script></body></html>